Oke, kita selesaikan dulu yang bagian communication ini ya. Nah, kita sampai di bagian multicast communication ya. Di situ kita sekarang sampai yang di bagian flooding base multicasting. Nah, di flooding base multicasting ini, ini mekanismenya jadi satu node ya, dia akan kirimkan pesan M di sini bilangnya ya ke neighbor-neighbornya. Kemudian pesannya ini mestinya oleh neighbornya akan kemudian diteruskan ke neighbor-neighbor yang lain. Itu caranya kemudian akhirnya semua node. Ya, akan mendapatkan pesan ini. Ya, itu yang floodingnya caranya begitu. Nah, ini mekanismenya itu misalnya node-nya itu Q ya, dia forwardkan message punya probabilitas itu kita bilang namanya P flood. Probability untuk apa namanya dari node-nya ini untuk menyebarkan pesan ini ke tetangga-tetangganya, neighbor-neighbornya. Nah, selain itu ada juga ya, parameter yang namanya pH ya, probabilitas satu node ini mempunyai, terhubung ya, terhubung atau terkoneksi dengan yang node-node yang lain. Ya, langsung aja pakai contoh ya. Jadi kalau misalnya ada satu jaringan terdiri dari banyak nodes, totalnya ada 10.000 node ini, ya kemudian pH-nya, probability S-nya 0,1, itu berarti masih, masing-masing node itu terkoneksi 0,1 kalau kita kalikan 10.000 kan berarti 1000 ya. Jadi masing-masing node itu terkoneksi dengan 1000 node yang lain. Ya, neighbor-nya jadi ada 1000 neighbor yang dia miliki untuk setiap node rata-rata. Ya, itu probabilitasnya seperti itu. Nah, kemudian berarti kan dia bisa ada kemungkinan dia akan nyebarkan ke neighbor-neighbornya ini ya, bisa sampai 1000 neighbor itu. Kemudian nanti, yang masing-masing neighbor yang terima pesan itu akan nyebarkan ke neighbor-neighbor yang lain, yang belum mendapatkan pesan itu tentu saja. Jadi kalau dia sudah pernah mendapatkan pesan itu, ya pesan itu nggak akan diteruskan. Ya, kemudian itu kita juga punya probability flat-nya itu 0,01, berarti kalau tadi dibilang setiap node itu punya, bentar ya, saya gunakan pointer mungkin supaya lebih jelas. Oke, jadi kalau setiap node-nya itu punya probabilitas terkoneksi dengan neighbor-neighbor node yang lain itu 0,1, berarti dia terkoneksi sampai 1000 node gitu ya. Nah, kalau P-flat-nya probabilitas dia untuk menyebarkannya itu 0,01, berarti dari 1000 node itu, dia nggak kirim ke 1000-nya ya, cuma ke 0,01 dari 1000 neighbor tersebut. Ya, jadi dengan demikian cuma 10. Ya, jadi cuma 10 neighbor yang dia kirimkan, kemudian nanti masing-masing neighbor-nya itu juga menggunakan setting probabilitas yang sama ya, jadi dia akan kirimkan ke 10 node yang lain lagi, 10 node lain. Misalnya contoh seperti itu ya, itu pun dengan yang jumlahnya cuma 10 tiap kali dikirim, 10 tiap kali dikirim ya, itu 5, ya mestinya tetap seluruh nodes itu, atau mayoritas dari node itu nantinya akan tetap terima pesan-pesan yang disampaikan itu. Dan jumlah pesan yang beredar ini, itu dibilangnya itu lebih, mestinya lebih nggak boros ya, 50 kali lebih nggak boros dibandingkan kalau kita melakukan full flooding, jadi masing-masing node kemudian sebar ke 1000, kemudian masing-masing 1000 itu akan kirimkan lagi ke yang lain ya. Itu kan bisa jadi, dia kirimkan, ke node-node yang sudah pernah dapat juga sebelum jadi, akhirnya itu wasted ya, boros. Ini kalau dengan yang cara begini, kita batasi dengan probabilitas gini, itu dari penelitian itu bisa pengurangnya sampai 50 kali, ya terjadi pengurangan ini lah, keborosan. Ya jadi bisa lebih hemat, tapi mencapai efektivitas yang sama. Di gambar di sini, itu juga bisa dilihat, kalau, PS nya berbeda-beda ya, PS kan berarti, koneksi antara satu node dengan neighbors nya itu seberapa banyak ya. Jadi kalau tadi contohnya 10.000 nodes totalnya, ya jadi kalau PS nya 0,2 berarti masing-masing node itu terkoneksi ke 2000 node yang lain. 0,4 terkoneksi ke 4000, kalau 0,6 berarti terkoneksi ke 6000 nodes yang lain gitu ya. Nah di sini juga bisa dilihat ya, apa namanya, kalau lihat grafiknya, PS yang 0,2 itu yang, ini ya yang paling bawah ya, kemudian 0,4 yang tengah, yang 0,6 yang paling atas. Jadi, dengan, probabilitas S nya ini semakin tinggi, tentu saja nantinya, jumlah nodes yang bisa dijangkau itu semakin banyak ya, semakin cepat juga akan mencapai, apa namanya, jumlah nodes yang akan mendapatkan pesan itu. Ya ini secara teoretis, pertama tengah, kalau pindah ke arah junior, mulai dari unit uni dengan unit nu bre, lalu atas PUS lagi,eternyai dari unit C denominant, jadi harusnya pinch 2. Kalau pindah ke awal,НumNo va ahorita dripping non-dividend, kalau puntual partition samaую, sehingga utih itu sangat banyak. Di awal berikut perangkangveniriness, ini classic set� Whoole Cancer, yang memang central 분위 ỡ di Amazon nya ya, ksat Éoter. Nah, Karena hypergip ini di contoh disini itu 4 dimensi. Ini kan juga totalnya ada 4 bit ya berarti ini 4 dimensi. Nah ini cara floodingnya itu dengan cara mengirimkan ke dimensi-dimensinya ini ya. Jadi ke 4 dimensi tersebut. Ini ada cara kerjanya penjelasannya bagaimana dilakukan dengan efisien. Jadi tidak boros ya pesannya. Bahkan ini bisa mengurangi pesannya itu tidak perlu dikirimkan sampai berulang ya. Ke node yang sama. Itu tidak mungkin terjadi. Karena ada pengaturan yang sangat baik kalau dalam hypergip ini. Kita coba lihat ya ilustrasi berikut ini. Jadi contoh ya kita punya hypergip seperti ini. Kemudian yang melakukan pengiriman pertama kali misalnya node 1001 ini. Dia akan flooding ke seluruh node yang lain. Kita lihat ada berapa langkah yang dibutuhkan sehingga bisa menjangkau seluruh node yang ada dalam hypergip. Jadi kita bisa lihat di sini. Jadi kita bisa lihat di sini. Nah tadi dibilang cara pengirimannya dikirim long dimension ya. Jadi sesuai dimensinya. Di sini kan ada 4 dimensi ya. Jadi 1001 akan mengirimkan ke 4 neighbor-nya. Jadi dia kirimkan neighbor ke 001 itu kalau dia sejalan dengan dimensi yang pertama ya. Yang paling kiri. Jadi. Kan dari 1001 dia akan terhubung. Ke 001 kalau kita ikutin yang dimensi pertama. Kalau ikuti yang dimensi kedua. Jadi yang bagian bit keduanya ini dia akan kirimkan ke neighbor 1101. Dimensi ketiganya 1011 dan terakhir yang 1000. Ini neighbor-nya itu terlihat di sini ya. Jadi dia kirim ke 001 yang dimensi pertama. Kemudian dimensi kedua ke bawah. Di sini. Dimensi yang ketiga itu dia ke depan. Kemudian dimensi empat yang dia ke kiri sini. Nah pada saat dia mengirimkan pesan ini. Dia kirimkan juga yang dimensinya. Jadi waktu kirim ke 001 pesan yang dikirimkan itu message-nya sendiri. Kemudian diikuti dengan dimensinya. Jadi dia kirimkan ke sini dengan dimensi pertama. Kemudian kirimkan ke 1101 M,2. Jadi dimensi kedua. Dan seterusnya. Karena kerjanya begini. Kenapa? Ini yang informasi yang kedua ini ya. 1, 2, 3, 4 dimensinya ini sangat penting. Sehingga itu nanti pengirimannya itu bisa beraturan. Kita coba ikuti lanjut ya. Jadi 0001 setelah menerima pesan dari 1001 ini. Dia akan meneruskan ke neighbor-nya. Nah caranya gini. Jadi karena dia melihat pesan yang dia terima itu M,1. Berarti. Yang pengirimnya itu sudah mengirimkan sejalan dengan dimensi pertama. Kalau dia misalnya kirimkan lagi ke yang berdi dimensi pertama. Dia akan balik ke sini. Karena dimensi pertama kan bagian ini ya. Yang pertama. Berarti akan balik ke sini. Jadi nggak perlu. Karena dia sudah dikirimkan M,1. Berarti dia sudah kirimkan ini di dimensi pertama. Ya dia jangan lakukan yang dimensi pertama lagi. Dia langsung lanjutkan. Jadi dia kirim ke dimensi pertama. Dimensi kedua, ketiga, keempat. Neighbor yang ada di dimensi kedua, ketiga, dan keempat. Jadi dari 0001. Dia akan kirimkan ke 0101, 0011, dan 0000. Ya sesuai dimensinya. Ya jadi yang di sini. Jadi dari sini ke bawah. Kemudian ke depan dan ke kiri. Ya. Sesuai dengan. Nah ini. Sekali lagi. Dia teruskan. Itu dengan informasi dimensinya ya. Jadi waktu kirim ke sini. M,2. Ini M,3. Ini M,4. Ya. Bagaimana dengan yang. Note 1101. Ini di sini ya dia. Nah dia karena dia terima M,2. Dia nggak mungkin. Nggak perlu kirimkan ke yang dimensi kedua lagi ya. Dan dia. Nggak perlu juga kirimkan ke dimensi yang pertama. Walaupun yang dimensi pertama kan sebelum. Kan ini kan. Cuma terkoneksi dengan yang dimensi kedua ya. Bagaimana dengan yang dimensi pertama. Nah yang dimensi pertama itu biarin yang diurus oleh note yang lain ya. Jadi instruksinya itu. Kalau dia terima M,2. Dia cukup teruskan ke neighbor. Yang dimensinya lebih tinggi dari 2. Jadi dia teruskan ke M,3 dan M,4. Itu ya. Jadi dia akan teruskan ke yang dimensi ke 3 dan 4. Dalam hal ini 1,1. Yang ini ya. 1111. Dan 11. 0,0. Bagaimana dengan yang 1011. Itu di sini. Karena dia terima M,3. Dia cuma teruskan ke. Ke dimensi yang keempatnya. M,4. Dalam hal ini yang 1010. Sini. Ya. Oke ini ya. Jadi ini. Yang. Lapisan pertama. Ya kemudian. Mereka teruskan ke neighbor. Ini yang neighbor-neighbor yang di lapisan kedua. Ya. Kita lanjutkan. Ini kan kan belum selesai semua ya. Karena. Masih ada beberapa yang belum terima pesan. Nah yang M,2 ini. Dari 0,1. 0,1. Karena dia 0,2 ya. Dia lanjutkan ke. Dimensi yang ke 3 dan ke 4. Ya. Jadi yang ke 3 ke sini. Yang ke 4 nya ke sana. Ya. Sementara kalau yang 0011. Itu berarti di sini. Ya. Dia sudah terima M,3. Jadi dia teruskan tinggal M,4 ke 0010. Ya. Terus lanjut yang 1111. Ini sini. Karena dia terima tadi M,3. Dia lanjutkan ke M,4 ke 1110. Ya. Sudah selesai. Ini yang lapisan ketiga. Dan yang terakhir lapisan ke 4. Itu tinggal satu aja yang belum ya. Ya ini yang akan lakukan yang 0111. Karena dia tadi terima M,3. Berarti belum selesai. Dia masih bisa teruskan ke M,4. Ya ke 01110. Itu cara kerjanya ya. Jadi. Maka ini bisa. Ini bisa awalnya bisa dari node mana pun ya. Untuk hypercube dengan 4 dimensi seperti ini. Itu berarti cuma dibutuhkan 4 langkah ya. Untuk bisa menjangkau semuanya. Mestinya dengan dengan ini kita bisa menarik kesimpulan ya. Kalau misalnya ini 5 dimensi. Ya berarti dia butuh 5 langkah. 6 dimensi dia butuh 6 langkah. Dan seterusnya. Ya. Oke. Bagaimana dengan struktur core. Ya. Struktur peer to peer lain yang kita sudah pelajari sebelumnya kan ini core ini ya. Bagaimana kalau mereka mau melakukan flooding. Ya. Apakah floodingnya juga bisa efisien ya. Jadi nggak perlu berulang ke banyak node ya. Kita coba lihat. Nah ini instruksinya bagaimana ini dilakukan flooding ya. Tapi saya untuk memudahkan menjelaskan saya gunakan sekali lagi ilustrasi ya. Oke. Kita punya core seperti ini. Untuk yang koneksi ke neighbor-neighbornya ini saya nggak perlu jelaskan kembali ya. Yang ini kan menggunakan kita bilangnya itu finger table ya. Jadi 1 node 1 dengan id 1. Dia terkoneksi ke yang i ke neighbornya yang plus 1 ya. Neighbornya yang plus 2 plus 4 plus 8 sampai plus 16 ya. Tapi ada beberapa yang. Mestinya arahnya itu ke node-node yang sama ya. Jadi makanya ini cuma misalnya 1 ini terkoneksinya yang ke 4, 9 dengan 18 ya. Dan 4 kemudian koneksi ke 9, 14 dan 20 dan seterusnya. Ya. Yang itu saya nggak perlu jelaskan ulang. Tolong dilihat kembali yang slide-slide yang sebelumnya ya. Penjelasan tentang core. Oke. Untuk yang ini contoh ini. Misal. Kita mulai dari yang node 9. Ya. Node 9 akan melakukan flooding pengiriman pesan ya ke semua node-node yang lain. Bagaimana ini dilakukan? Nah. Node 9 ini. Dia di dalam finger table-nya dia bisa melihat dia punya koneksi ke neighbor yang 11, 14, 18 ya. Dan terakhir 28. Jadi ada 4 neighbor ya. 11, 14, 18 dan 28. Nah. Dia kirim ke 4-4 ini ya. 11, 14, 18 dan 28. Nah. Waktu mengirimkan pesan itu dia juga menyatakan ya. Contoh ya. Yang dia kirimkan ke 11, 14, 18. Nah. Yang waktu dia kirimkan ke 11. Dia kirimkan pesannya kemudian diikuti dengan pemberitahuan. Oke. 11 kamu dapat pesan. Nah. Tolong teruskan pesan ini. Ke node-node neighbormu yang ada dalam range 11, 14 ya. Rangenya ini yang 11-nya yang kita bilangnya ini kan pipenya tertutup ya. Kalau yang 14-nya pipenya terbuka. Jadi kalau yang ini kan berarti ke node-node yang lebih besar sama dengan 11. Tapi lebih kecil dari 14 ya. Jadi ya 11, 12, 13 gitu ya. Pipe ini artinya. Nah. Jadi 11 ini. Waktu dia terima pesan. Dia ditugaskan juga untuk meneruskannya ke node-node yang ada dalam area ini. 11 sampai kurang dari 14 ya. Sementara kalau yang 14 diberitahu kamu teruskan 14 sampai 18. Ya. Jadi 11, 14, 18, 28 ini. Node 9 ini itu melakukan pembagian tugas gitu ya. Selain ngirimkan pesan M. Dia juga memberikan pembagian tugas ya. Jadi yang 11. 11 sampai 14. Sementara yang 14. Tugasnya dari 14 sampai 18. 18 tugasnya 18 sampai 28. Sedangkan 28 itu sisanya. 28 sampai balik lagi ke 9. Ya. Jadi masing-masing punya tugas itu. Punya area masing-masing. Jadi nggak akan bentrok. Ya. Oke. Kemudian kita lanjutkan. Ini lapisan pertama. Ya. Step pertama. Ya. Kemudian yang 11. Dia akan ditugaskan untuk sebelah. Ya. 11 sampai 14. Ya. Karena dia melihat. Neighbour-nya dia. Dia koneksi ke 14, 18, 20 dan seterusnya gitu ya. Nah. Antara 11 dengan yang 14. Dia kan. Diminta. Ditugaskan untuk mengirimkan. Kirimkan sampai kurang dari 14. Jadi 14 mestinya nggak termasuk ya. Jadi harus yang lebih kecil dari 14. Sementara dia nggak punya neighbour lain yang lebih kecil dari 14 ya. Jadi 12 dan 13 itu nggak ada. Neighbour-nya. Jadi 11 ini nggak akan meneruskan ke manapun. Jadi pesannya berhenti di dia. Dan dia kemudian nggak meneruskan ke node manapun. Karena tidak ada. Ya. Sementara 14. Sama kondisinya. Karena 14 dia terkoneksi pertama ke 18 ya. Kemudian yang lain-lain sudah lebih besar dari 18 ya. Jadi antara 14 sampai 18 nggak ada node-node yang lain. Jadi 14 juga. Tidak meneruskan pesannya. Bagaimana dengan 18? Nah 18 ini. Dia terkoneksi dengan 20, 28 dan seterusnya. Karena dia tugasnya itu 18 sampai 28. Ya dia akan teruskan ke yang 20. Sementara 28 itu di luar jangkauannya. Jadi dia akan teruskan ke node 20. Ya. Nah kemudian yang node 20 itu pada saat 18 memberikan pesan itu. Dia juga diberitahu. Kamu teruskan ini ke node-node yang berada di 20 sampai 28. Sampai kurang dari 28. Ya. Ini sudah yang kedua ya. Yang 28. Ya sebenarnya 28 nanti dia akan teruskan juga. Jadi yang ini yang dari 18 ke 20 ya. Mungkin kita tinggalkan dulu. Kita coba teruskan dulu yang 28 ya. 28 ini terkoneksi ke 1 kemudian 4. Kemudian sebelum. Ini 14 ya. 1, 4 dan kemudian ke. 14. Karena dia ditugaskan ke 28 sampai 9. Ya. Jadi dia akan dikirimkan ke 1, 4. Dan selesai ya. 1 dan 4 ya. Karena yang ini kan sudah 14 ya. Jadi sudah di atasnya 9 ya. Jadi cuma 1 dan 4. Jadi dia akan teruskan ke 1 dan 4. Dengan memberikan instruksi lanjutkan gitu ya. Jadi ke 1 ya. 1, 4. Yang 4 nya 4, 9. Ya. Ini jadi di lapisan kedua ya. Di langkah kedua. Pesannya itu menjangkau node 20, 1 dan 4. Ya. Kemudian kita lanjut. Yang dari 1 nanti akan coba teruskan. 4 coba teruskan. Yang 20 juga akan coba teruskan. Yang 20 tadi terima pesan dia diminta teruskan 20 sampai 28 ya. Nah dia terkoneksi cuma ke 21. Kemudian sudah langsung 28. Jadi dia akan teruskan ke yang 21 ini. Kemudian 21 diminta teruskan 21 sampai 28. Ya. Sementara kalau yang dari 1 dia terkoneksi ke 4. Ya karena dia ditugaskan 1 sampai 4. Berarti sudah gak ada yang perlu dikirimkan ya. Bagaimana dengan 4? 4 sampai 9 ya dia sudah gak ada. Karena neighbor nya yang terdekat 9 ya. Sementara 9 mestinya gak perlu dikirimkan lagi. Ya. Jadi selesai. Jadi yang di step ketiga yang dijangkau cuma 21 ya. Ya. Setelah itu selesai ya. Semua sudah terjangkau ya. Jadi 21 pun kalau diminta untuk meneruskan ya. Dia terkoneksi pertama ke neighbor yang 28 ya. Jadi antara 21 sampai 28 gak ada neighbor lain. Jadi dia gak bisa teruskan. Jadi bahkan untuk yang di kasus ini cuma 3 step yang dibutuhkan. Ya. Tapi nanti kalau misalnya susunannya beda. Note-note yang ada mungkin lebih banyak ya. Bisa jadi jumlah step yang dibutuhkan akan lebih banyak juga. Ya. Nah mestinya kalau disini totalnya ada 32 atau ini 2 pangkat 5 ya. Ini mestinya maksimum langkah yang dibutuhkan juga hanya 5 step ya. Kalau misalnya totalnya 64 ya total yang dibutuhkan mestinya ya juga 6 step ya. Sesuai dengan ini ya log n nya. Ya log n dasar 2 nya. Oke. Oke ini cara kerjanya yang core. Nah lanjut teknik lain selain flooding ada juga yang namanya gossip based data dissemination ya. Nah yang teknik gossip based ini sebenarnya bagian dari satu teknik yang kita bilangnya itu epidemic behavior. Jadi epidemic kita tahu epidemic itu bicara tentang penyebaran penyakit yang menular ya infectious diseases. Sama seperti yang apa namanya kondisi yang menular. Apa namanya kondisi yang barusan kita lewati waktu pandemi lalu ya. Itu kan epidemic dinyatakan sebagai kasus epidemic bahkan dianggap sebagai pandemic ya. Jadi kalau epidemic itu biasanya area nya lebih kecil terbatas. Tapi kalau sudah dinyatakan pandemic itu berarti area nya itu sampai ke seluruh dunia ya. Jadi bahkan lebih lebih parah gitu ya kalau kalau kasus namanya pandemic. Nah yang ini epidemic behavior sebenarnya belajar dari kondisi bagaimana. Penyakit ini penyakit menular ini disebarkan ya. Bagaimana mengirimkan pesan menyebarkan pesan ini ke banyak node dengan dengan dengan behavior nya itu seperti penyakit menular ini menyebar dari satu orang ke orang orang yang lain. Ya jadi dalam dalam konsep epidemic epidemic behavior ini ada tiga. Ada tiga kategori atau tiga kelas ya dari dari node node nya itu. Jadi ada node node yang kita bilang kasus statusnya itu infected. Berarti node tersebut memiliki penyakit dalam hal ini penyakitnya itu memiliki pesan ya pesan yang kemudian dia karena dia terinfeksi dengan pesan ini ya dengan message ini. Ya dia kemudian akan menyebarkan pesan ini ke node node tetangganya ya. Nah node node yang. Belum mendapatkan pesan ini atau dengan kata lain node node yang belum terinfeksi dengan pesan pesan ini kita bilang sebagai node node yang susceptible. Ya. Ini yang status kedua ya kategori atau kelas kedua ya. Jadi ada yang infected mendapatkan pesan. Kemudian ada yang belum mendapatkan pesan yang kita bilang namanya susceptible. Dan kemudian yang status terakhir atau kelas yang terakhir itu yang kondisinya remove. Jadi yang remove ini. Node node yang. Mendapatkan pesan infected ya tapi dia tidak tidak not willing ya jadi dia tidak mau menyebarkan pesan itu lebih lanjut. Ya jadi makanya dia kondisinya remove. Ya kondisinya dia nggak mau terlibat ya jadi nggak ikut menyebarkan penyakit atau menyebarkan message ini. Ya ini ini di algoritma yang epidemic behavior ini kita punya. Tiga kemungkinan. Kelas seperti ini ya infected susceptible sama yang remove ya. Nah lanjut. Saat data ini disebarkan message ini disebarkan. Tiap message itu punya timestamp atau ada versinya ya tujuannya untuk membedakan antara satu pesan dengan pesan yang lain. Ya jadikan pesan ini kan disebarkan bisa jadi kemudian ada pesan lain yang juga kemudian disebarkan. Nah bagaimana kita tahu. Pesan yang pertama ini dengan yang pesan yang kedua itu bukan pesan yang sama. Ya nah untuk membedakan itu makanya pesan pesannya itu bisa diberi timestamp atau diberikan versi ya ini pesan yang versi pertama ini pesan versi kedua ya. Atau diberikan timestamp tadi ya jadi karena perbedaan yang ini time pesan ini di generate. Pada pada timestamp sekian gitu ya. Beneran yang yang message pesan kedua nanti bisa dilihat. Apakah dia di generate pada timestamp. Apakah dia di generate pada waktu yang sama atau waktu yang lebih belakangan ya. Dengan demikian kita bisa tahu yang ini sama atau beda dengan pesan yang sebelumnya. Ya itu tujuannya memberikan timestamp atau memberikan versi ya. Kemudian model propagasi yang cukup populer di gossip base atau di epidemic behavior ini adalah yang anti entropi kita bilangnya. Ya di anti entropi itu ada tiga kemungkinan. Artian② Post狀장 Note yang lain itu note-note yang susceptible Note-note yang belum mendapatkan pesan Itu skin error pertama Jadi dia mekanismenya itu cuma push Dari yang infected Mudah-mudahan Diterima oleh note-note yang susceptible Bisa jadi pada saat dia push message ini Dia push ke message ke note lain Yang note ini ternyata sudah infected Maksudnya dia sudah terima pesan ini Ada kemungkinan seperti itu Nanti kita lihat Di skenario ini Apakah skenario ini cukup efektif Kalau kita cuma mekanismenya itu push Yang skenario kedua Itu mekanismenya itu pull Jadi note yang Sekarang kalau ini melakukan pull Note ini berarti note yang susceptible Dia belum mendapatkan pesan Dia belum infected Dia masih susceptible Jadi belum mendapatkan pesan apapun Nah dia Pull Menarik dari tetangganya Apakah ada pesan yang baru Yang saya perlu terima Jadi dia pull Update Apakah ada pesan baru Misalnya dari note lain yang Queue Bisa jadi Note yang tetangganya itu Note-note yang susceptible juga Jadi kalau dia susceptible Berarti ya tidak ada pesan baru Karena sama-sama Tidak mendapatkan message Atau mendapatkan penyakit itu Tapi Kalau dia misalnya pull itu dari Note yang infected Ya dia akan mendapatkan Pesan yang baru Itu skenario kedua Jadi pertama push Yang kedua itu dengan Skenario pull Dan yang ketiga itu Kombinasi keduanya Push dan pull approach Ya Nah dari penelitian Kalau kita gunakan skenario ini cuma push Ya Itu ternyata Kurang efektif Ya Terutama ini kalau Kondisinya itu sudah Banyak note-nya yang terinfeksi Karena sudah banyak note-nya yang infected Jadi Untuk setiap note itu Bisa menemukan Note baru Dimana dia mau push kan ya Dia push Message ini ke note lain Kemungkinan note lain ini Note yang susceptible yang belum mendapatkan Message Itu kemungkinannya kecil Sehingga bisa jadi Pada saat sudah terlalu banyak note yang infected Itu Naiknya sedikit ya Jadi sudah Sudah terlalu susah untuk mencari Note-note yang susceptible Jadi kurang efektif Modelnya kalau kita gunakan skenario Push Ini terutama sekali lagi Kalau Kalau Sudah terlalu Terlalu banyak note yang infected Ya Sebaliknya kalau kita gunakan yang skenario pull base itu Ternyata Baik ya hasilnya itu lebih baik daripada yang Skenario pertama Ya Terutama juga kalau misalnya kondisinya Banyak note yang sudah terinfeksi Karena mekanismenya itu pull berarti yang lakukan pull itu sebenarnya mereka yang susceptible jadi yang belum kena Nah kalau ada banyak neighbor-neighbornya yang infected Kemungkinan dia akan terinfeksi yang susceptible ke kemungkinan terinfeksi akan sangat sangat besar Ya jadi pada saat Apa namanya pesan-pesannya ini sudah tersebar banyak ada many notes yang Infected Yang susceptible notes pun masih akan mendapatkan update Ya itu itu yang keuntungan dari menggunakan yang model pull base ini Ya Secara overall dibilang Strategi yang kombinasi keduanya push dan pull itu Dirasa lebih baik dibandingkan yang Push only ataupun yang pull base Ya Oke Nah varian dari yang epidemic Behavior ini yang kita bilang sebagai Gossiping atau rumor spreading Ya ini bicara tentang gossip based data dissemination Ya Cara kerjanya seperti ini jadi itu Kalau yang ini Ya Secara dasarnya sama sama dengan yang tadi yang di epidemic tadi ya Jadi setiap note itu dia akan Coba push kalau disini yang coba dilihat cuma yang skenario push ya Dia akan coba push update Ke note yang lain ya ini gossip Jadi sama ya epidemic ini makanya dibilang namanya juga Gossiping ini variannya dari yang epidemic Kalau yang gossiping sama ya jadi kalau kita mendapatkan rumor Atau pesannya itu jadi disebut sebagai rumor Nah rumornya ini kemudian disebarkan ke tetangga-tetangga yang lain ya Menggossip ya menggossip tentang rumor ini ya dengan tetangga yang lain ya Harapannya tetangga yang lain kemudian akan mendapatkan rumor ini kemudian akan Nyebarkan lagi rumornya ke tetangga-tetangga yang lain ya Ini yang mekanisme gossiping seperti ini Nah disini Di ilustrasi ini kita juga bisa menggunakan Variable yang probability ya probability stock Jadi ini kemungkinan Kemungkinan satu note ya Untuk menjadi remove Masih ingat ya tadi kan ada tiga status ya Infected, susceptible, sama yang remove Jadi probabilitas Note yang infected itu menjadi remove itu probabilitasnya kita bilang yang P stop ini Jadi dia stop untuk menyebarkan rumor ya Dia tidak mau lagi menyebarkan rumor Dia mendapatkan rumor tapi dia tidak menyebarkan atau meneruskan ke tetangga-tetangga yang lain ya Misalnya kita main dengan probabilitas itu P stop Di ilustrasi ini dibilang ya Jadi kalau probabilitas P stop nya itu 0,2 atau 20% gitu ya Itu maka ada Ada kemungkinan beberapa notes ini oblivious notes itu notes yang susceptible ya Jadi yang mereka belum mendapatkan rumor ya Kalau jadi probabilitas yang P stop nya itu 0,2 Ada kemungkinan beberapa notes ya Itu masih oblivious dia nggak mendapatkan rumor itu Atau nggak mendapatkan message itu Tapi probabilitasnya sangat kecil sekali disini ya Ini kayaknya kurang dari 0,01 Kalaupun kita tingkatkan yang P stop nya ini misalnya menjadi 0,4 ya Jadi 0,4 dari yang infected Atau 40% dari yang terinfeksi itu nggak menyebarkan lagi Mereka menjadi remove gitu ya Itu pun notes-notes yang masih belum mendapatkan rumor itu masih ya kurang dari 5% 0,05 Kita tingkatkan lagi 0,6 0,8 bahkan sampai 100% ya Semua yang infected itu menjadi remove ya Itu pun ternyata Sampai 0,2 saja ya Atau 20% aja yang belum mendapatkan rumor ya Jadi ini Dengan kata lain Gossiping ini sangat efektif untuk menyebarkan message menyebarkan rumor ya Walaupun ada notes-notes yang menjadi remove setelah infected dia kemudian menjadi remove itu pun Tetap jumlah notes yang tidak mendapatkan rumor ini cukup kecil Itu keuntungan dari yang model Gossiping atau yang epidemic ini Jadi skalabilitasnya itu sangat baik ya Jadi karena mekanismenya sederhana Jadi ini skalabilitasnya juga kalau jumlah notesnya makin banyak itu nggak masalah dengan teknik seperti ini Oke Nah yang bagian ini saya skip aja nanti kalian bisa baca ya Saya mau point out yang pentingnya Tentang side effect ya dari algoritma epidemic maupun yang Gossiping Jadi ada side effect yang mungkin nggak terlalu diharapkan ya Itu adalah kesulitan kalau kita mau menghapus pesan ya Jadi kalau misalnya pesan atau rumor ini sudah disebarkan gitu ya Kemudian ternyata rumornya ini nggak benar gitu ya Jadi kita mau menghapus rumor ini gitu ya Menghapus message-message ini supaya jangan disebarkan lagi ya Supaya jangan disebarkan lagi karena ini hoax misalnya ya Jadi hal yang salah jadi kita nggak perlu sebarkan ulang ya Itu sulit dilakukan ya Kenapa yang melakukan deletion atau penghapusan rumor ini sulit dilakukan karena statusnya gini Kalau misalnya kita menghapusnya itu dengan membersihkan dari satu note ya Jadi satu note ini misalnya terinfeksi Kemudian dia akan berusaha untuk menyebarkan rumor ini ke tetangga-tetangga yang lain Yang belum mendapatkan rumor kan Dia akan coba gitu ya Nah misalnya kemudian kita bilang ini rumornya ini salah hoax gitu ya Jadi kemudian kita mau stok Jadi kita hapus jadi yang note yang infected ini kita hapus rumornya sehingga dia menjadi yang susceptible Statusnya mestinya kan berubah karena dia nggak dapatkan pesan lagi Dia nggak memegang pesan itu, nggak memegang rumor itu Jadi dia statusnya menjadi susceptible Nah akan besar kemungkinan yang susceptible ini dia akan mendapatkan rumor yang sama Jadi rumor yang kita mau stop ini, mau hentikan ini Kita bersihkan dari note-note yang infected Sehingga yang note-note ini menjadi susceptible Yang susceptible ini kemungkinan akan menjadi infected lagi karena dia terkena lagi yang rumor dari note-note lain yang belum sempat kita bersihkan Jadi sangat sulit untuk membersihkan rumor ya Ini kondisinya sama seperti yang kondisi real ya Jadi kalau sekali rumor itu keluar ya Sangat-sangat sulit lah untuk menghentikan rumor ya Walaupun rumor itu rumor yang salah ya Ya ini sama jadi kondisinya seperti itu Ini yang kita bilang sebagai side effect Jadi sulit ya Jadi ya lesson-nya itulah hati-hati ya kalau mau menyebarkan rumor Apalagi rumor yang nggak benar Oke Nah bagaimana ini bisa dilakukan di teknik ini Kita nggak bisa melakukan penghapusan, deletion dari rumor atau message ya Yang kita bisa lakukan rumor message yang salah ini Kita override ya Kita tumpuk atau kita tambahkan lagi dengan message yang baru Jadi ada message baru yang menggantikan message yang lama Tadi kan message-message kan ada timestamp-nya atau ada versinya ya Jadi kita berikan yang message yang lebih baru Dan message yang lebih baru ini bisa kita bilang itu mengoreksi yang salah tadi Ya Nah yang kita lakukan yang message yang baru itu untuk menghapus data yang lama itu Yang kita sebarkan itu kita sebut sebagai Death Certificate Ya surat kematian Ya jadi pesan rumor-rumor yang sudah bergerak itu Kita sertai dengan Death Certificate Untuk rumor tersebut Death Certificate ini jadi akan spesifik ya Ke pesan atau ke rumor yang mana Ya Nah ini kita sebarkan sekalian Ini kan jadi Death Sixticate akan menyebar seperti gosip gitu Ya Harapannya ini sebar jadi ya Semua yang infected Itu akan mendapatkan Death Certificate Ya kemudian dia Ya ini karena rumornya dibilang sudah dead ya Dia kemudian nggak menyebarkan lagi ya Yang dia sebarkan yang Death Certificate nya aja yang dia sebarkan yang lebih baru Ya jadi yang Death Certificate akan dikirimkan ke rumor-rumor yang lainnya ya Yang Death Certificate akan dikirimkan ke not-not lain yang mungkin belum mendapatkan Ya dengan cara ini akhirnya yang rumornya itu Nggak disebarkan lagi karena akan ada yang lebih baru ya Death Certificate nya yang kemudian disebarkan Oke gitu ya caranya jadi Cukup cukup sulit ya menghapus rumor yang sudah terlanjur keluar Oke Nah bisa jadi yang Death Certificate itu kalau sudah cukup lama Bisa jadi Death Certificate nya itu sudah terlalu banyak ya 후� konon pratik Cukup selalu тради L operated Cukup selalu тради untuk memastikan bahwa yang dead certificate ini untuk menghabuskan untuk meng-counter rumor ya jangan sampai kalau dead certificate-nya itu nanti dihilangkan yang dormant ya ini setelah dihilangkan malah rumornya itu bergerak lagi gitu ya supaya jangan sampai begitu biasanya tetap ada beberapa ada node ya beberapa node yang tetap memegang dead certificate itu jadi tidak dibersihkan keseluruhan ya, jadi masih ada beberapa ini dibilang ya, few nodes maintain dormant dead certificate jadi untuk jaga-jaga ya supaya nanti kalau misalnya ternyata rumor yang salah itu muncul kembali ya kemudian ya karena ada dead certificate ini itu menyebar kembali yang dead certificate-nya oke, itu yang terakhir menurut saya ya, itu yang terakhir terkait dengan yang gossip based data dissemination ini ya, oke, nanti kalau ada pertanyaan nanti saat kita ketemu di kelas silakan ditanyakan ya terima kasih