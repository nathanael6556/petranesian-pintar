Ok, we let's finish the communication part first. We are at the multi-cast communication part. From there we are at the flooding-base multicasting. On the flooding base multi-casting, this is the mechanism. So, at the node, it will send a signal to the neighbor. The signal will still be sent to the neighbor, the other neighbors. All nodes will get the signal as a result. That's how the flooding goes. if it is a function that is changed to "Q", then the message has a probability to spread the message to the neighbor. There's also a color parameter called pH. The probability of this note having a connection with the other note notes. Just use the example. So if there's a link and there are 10,000 notes total and there's an average of 10,000 (PH, PLE, P5, P5, etc). P H probability H = 0.1 means "Knot" is connected to the "Knot" if we multiply "Knot" by 10 thousands, that means 1000 So, each "Knot" are connected to the "Knot" with a thousand "Knot". The neighbors comes with thousands of neighbors. That is the probability. it will leave to the neighbor here until 1000 neighbors and then, every neighbor that receives the message will leave it to the neighbor that hasn't got the message. So, if it has receive the message, it won't continue. then we also have probability flat, that is 0.01 that means, if said as always, every note has ... Wait, I'll use a pointer to see more clearly. Okay, so if every note has a probability of connecting with other neighbor-neighbors 0.1, that means they connect to 1000 nodes, right? If the P flat probability is 0.01, so from 1000 nodes, they do not send it to 1000 but to 0.01 from 1000 neighbor, so with the number only 10. So there are only 10 neighbors that are sent. Then each neighbor also uses the same probability setting, or the same, so it will send to 10 notes again and again, 10 notes For example for example like that, it is with the number of 10 each time, 10 each time sent, that must still get the note, or the majority of the notes will be received, and these bars in the middle is 50 times more than the full flooding, so each notes are 1,000 pounds and each is sent to another one. It is being sent to the node that has been obtained before it is wasted. For this case, our way to limit the probability of the reduction by 50 times can be reduced to a reduction, so it can be more efficient but it can achieve the same effect. In the images that were displayed, this is the difference between previous / new and previous nodes. The previous real works are the connection between each node. The neighbors are actually very different from each other. The total nodes of previous nodes are 0.2, which means each node is connected to another node. When it's 4,000, it is connected to 6,000 notes. Here you can also see the graphic performance. The PS on 0.2 is the lowest one and the 0.4 on the middle one, the 0.6 on the top one. With this S-probability, the higher the note, the more likely the amount of notes to be eliminated. as longer as possible, it will be faster and it will get deeper. This is the basic flooding based multi casting. Now let's look at its practical example, for real example, the practical of flooding based multi-casting. For example, we have seen before it on the structure of beer2peer. The shape is hypercube. If we do flooding in Hypercube, 4 dimensions are possible, this is 4-bit. The way to flood, it means to send to 4 dimensions. the way of working is to explain how how efficient it is. So there is no difference. The problem is not to be sent to repeat the same note. It's impossible because there are some very good control in the hypergroup. We try to look at the next illustration. For example, we have this hypergroup, nc1.001 is flooding into other nodes. We can see several steps that are needed. Send to the sender. So according to dimension, there is 4 dimensions in this list. to the neighbor. So he sends the neighbor to 0.001, that is, if he walked with the first dimension, the left one, the other from 1.001 will be connected to 0.001 if we follow the first dimension. If you follow the second dimension, so the second then it will send this 2nd bit to the neighbor 1 1 0 1 the third dimension is 1 0 1 1 and the last 1 0 0 0 this neighbor will be sent to 0 0 1 first dimension then the second dimension to here Dimension 3. It goes forward, then Dimension 4 and it goes left here. When it sends a message to the lost object, it even sends the dimensions, so when it sends it to theflg1.0.1, the message sends itself, then followed by the dimension, so it send it here with the first dimension, then send it to 1.1.0.1, the dimension is 2. And the next, how to do it like this. Why? The second information, 1, 2, 3, 4, the dimensions are very important, So that the user can handle it. We try to continue. So the one, one, zero, zero, one, after receiving the message from one, zero, zero, one, It will keep its neighbor. So, the way it is like this is because it looks at the message received M.1, that means thenun who sent it has sent it along with the first dimension. If he sends it again to the first dimension, he will go back to here. Because the first dimension part is, that's where he goes back to here. He doesn't need it. Because he has been sent M.1 that means he's sent it in the first dimension. Yes, he doesn't want to go to the first dimension anymore. she immediately continue Yes so she sends to dimension 2 to 34 neighbor which is in dimension 2 to 34 So from 0 0 0 01 She will send it to 0 01 0 1 0 1 1 1 and 0 0 0 0 Yes according to the dimension. So the one here So from here to below then to the front and left yes In this case, he keeps using the dimensional information, you see. So when he sends it here, it's m.2, this is m.3, this is m.4 How about the node 1.1001? Here he is. He's because he gets the m.2, he doesn't need to send the second dimension. And he... do not need to send it to the first dimension, even though the first dimension is a connection between the second dimension and the first dimension Now, the first dimension is to be let be directed by a different node, so the instruction is that if he receives a m.2, he will continue the neighbor which has a higher dimension than the second So he will continue to m.3 and m.4 So, it will go on to dimension 3 and 4 in this case 1 1 1 1 1 1 1 1 1 0 0. How about 1 0 1 1 1, here it will accept M.3, just continue to the 4th dimension, M.4, in this case 1 0 1 0 1 0 0 here. oh, then this is the first layer. and then they continue to the second layer, the next layer. We continue, this is not all finished yet. There are some that are not accepted yet. This m.2 from 0 1 to 0 1, because it is 0.2, it continues to the figure 3 and 4. onto the third, the fourth, etc. so in the example of 00111, backward, they already με 3, so they left 4 to 0010. then, next, 11111, here, because they accepted M.3, they went to M.4 to 1110. this is the third row. and the last layer, layer 4, is only 1, which is not done yet. This will be done with 0, 1, 1, 1. Because it accepted M.3 earlier, so it's not complete, it can still go up to M.4, 0, 1, 1, 1, 0. That's the way we work. So by the way, it can start from a node, whatever. for hypercube with 4 dimensions like this, which means it just requires 4 steps to be able to connect all of them. This, for sure, will attract us to the conclusion. If, for example, there are 5 dimensions, it needs 5 steps, 6 dimensions, it needs 6 steps, and so on. What about the structure of the core? The structure of other pieces that we've already learned, right? This is the core. how would they do flooding? or if it can also be efficient? so, we don't need to do many more. let's see the instruction how to do flooding but I will explain it in more detail I'm using a scale of illustrations okay we have this sort of chords for the ones Connecting this to the neighbor of this neighbor, I do not need to explain it again, yes this one is using, we says it's a finger table, yes so one node one with ID 1, it connects to the neighbor that is +1, yeah the neighbor that is + 2 + 4 + 8 until + 16, yes but there is a few that Of course, the direction is the same to the same note. So only it has 1 interconnection that is to 4, 9, with 18, and 4 and then the connection to 9, 14, and 20 and so on. I don't need to explain it again, please take a look again, that is the previous slide on code. For this example for example, Let's start with Node.9. Node.9 will load the shipping of the files to all the other Node nodes. This Node.9. in the table, there is a connection to the 11th, 14th, 18th, and the last one is 28th. means there are 4 nipper ... yes, 14, 18, and 28. It sends to these 4 nipper ... yes ... 14, 18 and 28, At that time it sends a message, it is also turns out ... for example, it sends to these 14 nipper .... At that time it sends to these 11, it sends the message, then followed by ... OK, you get a message, please continue this message to your "notenote neighbor" which is in range 11.14 the range this 11... which we have mentioned This is a closed pipe if the 14 pipe is opened so this means to the "notenote" which is bigger than 11 but smaller than 14 so yes 15,12,13 this is the tone for this pipe so this 11 So while he receives a call... he is also assigned to continue this note note in this area... 11 to... uh ... less than 14. While the 14th note is learned, you continue from 14 until 18. Yes, so 11/14/18/18... 8th note 9s... does the part of the call. Unless you send a call M... he also gives the part of the call. So, the first 11 is 11 to 14, middle 12 is 14 and the second 14 are 14-18. The 18th is 18 to 28, and 28 to go back to 9th over. So, each worker has to have each area so that it will not be blocked. Ok, next is the first step. and then the 11th, it will be charged for 11 to 14 because the neighbor connects to 16, 18, 20 and so on the 11th and the 14th they will be charged to send you to not less than 14 so 14 is not included, so it must be smaller than 14 The neighbour is not smaller than 14, making it 2 and 13 No neighbour So the neighbour will not continue to the other side so it stops the connection And it will not continue to the other side because there is no neighbour the neighbour's connection is the same Because the neighbour connect to 18 and then the neighbour is already bigger than 18 So between 14 and 18 there is no neighbour what do you think about this ? how do you know? 18 is connected to 20, 28 and so on because it will follow to 20 while 28 is outside the number so it will go to 20 then the 020 when 18 gives the signal also by informing. You continue this note note that is 20 to 28, less than 28. This is the second one. Those 28, it will continue later. This one from 18 to 20. Maybe we will leave it first, let's try to continue towards 28. 28 is connected to 1 then 4 then 11 and this is 14 yes 1 4 and then 14 because it is attached to 28 to 9, that means it will send it to 1 4 and I am done 1 and 4 because this is already 14 so it's already above 9. So it's only 1 & 4 so it will continue to 1 & 4 by giving another instruction, so 1.4, 4.9 this is the second step because it says node 20, 1 & 4 Then we continue. The first one will continue. The second one will continue. The third one will continue. The second one will continue. The second one will continue. The first two will continue. The third one is given the order of the second and the second. The first one is given the order of the second and the second. The second one is given the order of the third and the second. So, the fourth one will continue to the second and the second. The fourth one will continue to the second and the second. Meanwhile, the first one is given the order of the fourth. The fourth order is given the order of the fourth. You know, so it doesn't mean that there is no need to deliver anymore. How about with 4-9? Well, they don't have any anymore. Because the closest neighbour is 9 of them. After 9, they may not have to deliver anymore. So when the third step was ended, the one that was submitted was only 21. After that, everything was already submitted. So, even if it was a request, The first connection is to the neighbor, which is 28. So between 21 and 28, nowhere else. So it can't continue. So even for this case, it was just three steps that were needed. But later, for example, if the apocalyptic map is different, there might be more notes, it will be possible that the number of steps needed will also be more. it's important that if total is 32 or 2 notes you have to have maximum5 step if total is 64, it has to be 6 steps according to the log n this is the working method Next techniques beside flooding are also called gospel base data dissemination The gospel base technique is actually a part of one of the techniques called epidemic behavior We know that the epidemic is a way of spreading serious diseases It's just like how we just passed the pandemic. The epidemic has been declared as a epidemic. It's a minor area, but if we already declared that it's a pandemic, it means that the entire world would be affected. The biviric epidemic has learned from the condition of the elderly sick person. How to send this message to the Bank of America, via the Biviric, which is like the deceased sick person. this is spread from one person to another. So in this concept of epidemic behavior, there are three categories, three classes from the node-node. so there is a node-node that we call the "Infected". The node has the disease. In this case, the disease has a message. because it's infected with this message() it will spread this message to the notes of the letter of the letter. Note notes that.... ...still haven't got this message or ... note notes that are not infected with this message, as a note note that has a certain value. This is the second status category. The last status is "Infected" and the last status is "Remove". so the removed node put has infected the whном, but it's not really not feelings so it don't want to spread the message to the next node so it remove the condition, it don't want to spread this message In the algorithm for Epidemic Delivery, we have three cases like this, Infected, susceptible and removed. Next, when this machine is powered by the message, each message has free time-stamps or versions. You can divide the balance between 1 sign and the other sign. So this sign can be divided, so there are other signs that are also divided. So how do we know the first sign with 2 sign is not the same sign? To differentiate it, it means that the sign can be times stemmed or given the second version, whereas the first sign and second sign have been given the same sign. This is because of the difference. This message was generated at the same timestamp. Actually, the second message can be seen later. Is it generated on the same time or on the later time? With, maybe, we can know whether this is the same or different from the previous message. That's the purpose of the timestamp or version. Then the propaganda model that was very popular in the gospels, or in the epidemic-based, is the anti-entropy, as we said. In the anti-entropy there are 3 possibilities of sending this message to others. in some first scenario, the infected node with a message is pushed. Push -updates or push -messages or push -dices are to the other node. In other words, the other node is a susceptible node, a node that does not receive a message. So the mechanism is a push from the inveterate to the other node that is already been infected. When we look at this, is it effective enough for the scanner to be able to boost it by Can is the second mechanism is pulling. So the node that... If this is pulling, which means it is not able to get a message yet, but is not infected, it is still been able to make a message and it is still pulling. to draw from his compatriot's, "Is there a new query that I need to get?" So, he pulls, updates. "Is there a new query from the other node that must give?" So, the target node, is a susceptible node. So, if it's susceptible, I mean, there's no new query. Because we do not get any message or disease. But if was said to be pooled from the new infected node, he will be able to receive a new message. That is scenario 2. First, the pooled one, and then the pooled one, and the third one is the combination of pool and pool approach. From the research, if we used the pooled one, It turns out not that effective. Especially if the condition has had a lot of infected nodes because of the infected nodes so for each node, it can find a new node where it will push this message to another node But the ability of another node, this is a susceptible node that hasn't received a message, it might be too little. Therefore it is possible that when there is too much infected nodes, it goes up a little bit. Therefore it is not too difficult to find a susceptible node. So the model is less effective when we use the push scanner. especially if there are too many of the infected nodes. In fact, if we use a favoritized pool base, it turns out the results are better than the first scenario especially if the condition of the nodes is infected, because the mechanism is a pool So that makes it more susceptible, so it hasn't hit Of course there are many of the infectable neighbors They may be infected, but those of the infectable will be too high So when there are many more infectable neighbors but there are many infectable nodes The susceptible nodes will still get new update Those are the advantages of using the PULBEAS model. Overall, the combination strategy for PUS and PUL is better than PUS-only or PULBEAS. The variation from the epidemic behavior that we mentioned was gossiping or rumor spreading. This is talking about gossiping, data distribution, and information. So, in the general way, this is the same as in the epidemic earlier. So, every node will try to push, if you look here, just like the scenario push, it will push up to another node. And this is the same epidemic, so called go-sipping was the variant of the epidemic. So, if we get the rumor or the message as a rumor, the rumor will be spread to other earths, to gossip about this rumor with others. Hopefully, the other earths will get the rumor, and then spread the rumor to other earths. This is the gossiping mechanism. Here, So in this illustration we can also use a variable which is probability stop. So this is a single node to be remove. Do you remember the 3 factors? Infected, susceptible, and remove. So, probability... The inverted note in fact, is a result of the probability of being removed. We call it as the Paste Top. So, he stops to spread rumors, he doesn't want to spread rumors again, but he does not spread or go straight to other topics. For example, we play with the probability of the Paste Top. In this illustration, So this illustration is said, so if the probability of the top 0.2 percent or 20 percent is zero, then there could be some nodes, for some reason, the oblivious nodes are susceptible, and they don't get the rumor. For probability that the PSTOP is 0.2, there are several nodes that are still oblivious. The probability is very small. It seems that this is less than 0.01. So even if we increase this PSTOP to 0.44, and 0.44 is an infected person, or 40% is a新 infected person. It will be removed. Even the Note that hasn't received open-air usage is still less than 0.05. Let us go back to 0,6 / 0,8. Even until 100%. The fact that all of those infected were removed… It turned out it's only 0,2 or only 20% that have not got the removal. with other words, this Gossiping is very effective to spread message, spread rumor although there are notes that is removed , instead of infected and it is removed, the number of notes that is not found in this rumor is small that's a blessing from the Gossips or Epidemics model Ok, so the scalability is very good so because of the mechanism And this scalability, too, if the number of dots is increasing, no problem with techniques like this. Ok, so I skip this part, you can read it later. I want to point out that the side effect of the epidemic algorithm is not successful. There is a side effect that may not be successful. That is a difficulty if we want to remove the message. So if the message or rumor has been spread, then the rumor is not true. so we want to delete this rumor, delete this message so that it is not spread again because this is what is wrong, so we don't need to separate it back. It's difficult to do. Why do deletions or removing rumors are so difficult? Because the status is like this, if, for example, So if we take the moldet, from one note to another, and one note has been infected. It will try to separate the rumor from other notes. If we say that the rumor is a wrong tuning, we can choose to talk. So, we delete the node that is infected, we delete the rumor So it becomes susceptible. The strategy is to make sure it doesn't change or catch rumor again. So the strategy is to become susceptible Maybe it will be bigger, because the patient has the same rumor that we have to stop it before we clean them from the infected note to save them from the infective one. So it is very difficult to clean the roomor. And this condition is the same as the real condition. So if that roomor comes out, it is very difficult to stop the roomor. Even though the roomor is the wrong one, right? It's the same so the condition is the same. This is what is said as the side effect. So it is difficult. So your lesson will be careful if you want to spread the roomor especially rooms that are not right. So, how do you do this? In this technique, we can't do the delete duration of a rumor or message. What we can do with this wrong rumor message is we overwrite. We add new messages with new messages. So, there are new messages that replace old messages. Earlier, the messages had timestamps or versions. So, we will give new messages to correct the wrong ones. We will distribute the new messages to remove the old data. The playoff of all the rooms has been played we have run online with Dat-Certificate. Sample of the room to be called Dat-Certificate will be specific to all the rooms. This is what we just explained Infected, so Dat-Certificate will spread like gossip. Hopefully, it's new. All Of the inflases will have Dat-Certificate and it will be used for the room. it doesn't spread again, the one with the certificate is the one with the newer one. So, the certificate will be sent to other node that maybe it's not got. With this method, the rumor is not spread again, because there will be the more recent one. The certificate is spread. So, the method will be difficult eradicating the rumor that has been spread. If the Death certificate is long, the death certificate has been too many. We need to have the mechanism, this is the same as garbage collector. So the messengers who have not been used, especially those who have received this certificate, in a routine way, but it must be cleaned well. especially for the dead certificate that has been in the dormant, there is a mechanism in here to clean it up. of course just to make sure that the dead certificate is to remove, to counter rumor, don't until the dead certificate is later destroyed, the dormant sir. This has to be said for the rumors to continue. Don't be like that. There are usually some notes, which still holds the date certificate. So that it will not be updated all the time. These are some notes, give you notes to maintain the date certificate. So be aware, as soon as the wrong rumor appears again, Because we have this dessert week, we can spread it back to the dessert week. Okay, that's the last one, I think. Yes, that is the last one related to the do-it-yourselflements of this dissemination. Okay, if we have any questions, when we meet in class, please ask them. Thank you. you